// ===== THREE.JS AVATAR 3D =====
let scene, camera, renderer, robot, mouthMesh;
const avatarConfig = {
    headRotationX: 0,
    headRotationY: 0,
    mouthOpen: 0,
};

function initThreeJS() {
    const container = document.getElementById('canvas-container');

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1929);

    camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
    );
    camera.position.set(0, 0.5, 2);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0x00d4ff, 0.8);
    directionalLight.position.set(5, 10, 7);
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0x00ff88, 0.5);
    pointLight.position.set(-5, 5, 5);
    scene.add(pointLight);

    createRobotAvatar();
    window.addEventListener('resize', onWindowResize);
    animate();
}

function createRobotAvatar() {
    robot = new THREE.Group();
    scene.add(robot);

    const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        metalness: 0.8,
        roughness: 0.2,
    });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.castShadow = true;
    robot.add(head);

    const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
    const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });

    const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
    leftEye.position.set(-0.18, 0.15, 0.48);
    head.add(leftEye);

    const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
    rightEye.position.set(0.18, 0.15, 0.48);
    head.add(rightEye);

    const visorGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.05, 32);
    const visorMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        metalness: 1,
        roughness: 0.1,
    });
    const visor = new THREE.Mesh(visorGeometry, visorMaterial);
    visor.position.z = 0.45;
    head.add(visor);

    const mouthGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.1);
    const mouthMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        metalness: 0.6,
        roughness: 0.4,
    });
    mouthMesh = new THREE.Mesh(mouthGeometry, mouthMaterial);
    mouthMesh.position.set(0, -0.15, 0.48);
    head.add(mouthMesh);
    mouthMesh.userData.defaultScaleY = 0.08;

    const neckGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.3, 16);
    const neckMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        metalness: 0.5,
        roughness: 0.3,
    });
    const neck = new THREE.Mesh(neckGeometry, neckMaterial);
    neck.position.y = -0.55;
    robot.add(neck);

    const shoulderGeometry = new THREE.BoxGeometry(1, 0.4, 0.4);
    const shoulderMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        metalness: 0.5,
        roughness: 0.3,
    });
    const shoulders = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
    shoulders.position.y = -0.85;
    robot.add(shoulders);

    const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.8, 16);
    const armMaterial = new THREE.MeshStandardMaterial({
        color: 0x666666,
        metalness: 0.6,
        roughness: 0.3,
    });

    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
    leftArm.position.set(-0.5, -0.85, 0);
    leftArm.rotation.z = Math.PI / 8;
    robot.add(leftArm);

    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
    rightArm.position.set(0.5, -0.85, 0);
    rightArm.rotation.z = -Math.PI / 8;
    robot.add(rightArm);

    const panelGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
    const panelMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a3a52,
        metalness: 0.4,
        roughness: 0.5,
    });
    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
    panel.position.set(0, -0.9, 0.25);
    robot.add(panel);

    const glowGeometry = new THREE.SphereGeometry(0.55, 32, 32);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00d4ff,
        transparent: true,
        opacity: 0.1,
        wireframe: true,
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    robot.add(glow);
}

function animate() {
    requestAnimationFrame(animate);

    robot.rotation.x += (avatarConfig.headRotationX - robot.rotation.x) * 0.05;
    robot.rotation.y += (avatarConfig.headRotationY - robot.rotation.y) * 0.05;

    if (mouthMesh) {
        mouthMesh.scale.y += (avatarConfig.mouthOpen - mouthMesh.scale.y) * 0.1;
    }

    robot.position.y += Math.sin(Date.now() * 0.0005) * 0.001;

    renderer.render(scene, camera);
}

function onWindowResize() {
    const container = document.getElementById('canvas-container');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

// ===== TEXTâ€‘TOâ€‘SPEECH & LIPâ€‘SYNC =====
const synth = window.speechSynthesis;
let currentUtterance = null;

function speakText(text) {
    if (!synth) return;

    synth.cancel();
    currentUtterance = new SpeechSynthesisUtterance(text);
    currentUtterance.lang = 'it-IT';
    currentUtterance.rate = 1.0;
    currentUtterance.pitch = 1.0;

    const duration = text.length * 50;

    currentUtterance.onstart = () => {
        updateStatus('ğŸ™ï¸ Parlando...');
        animateLipSync(duration);
    };

    currentUtterance.onend = () => {
        avatarConfig.mouthOpen = 0;
        updateStatus('Pronto a conversare');
    };

    currentUtterance.onerror = () => {
        updateStatus('âŒ Errore nella sintesi vocale');
    };

    synth.speak(currentUtterance);
}

function animateLipSync(duration) {
    const startTime = Date.now();
    const interval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;

        if (progress >= 1) {
            clearInterval(interval);
            avatarConfig.mouthOpen = 0;
            return;
        }

        const mouthPattern = Math.sin(progress * Math.PI * 4) * 0.5 + 0.3;
        avatarConfig.mouthOpen = Math.max(0, mouthPattern);

        avatarConfig.headRotationX = Math.sin(progress * Math.PI * 2) * 0.05;
        avatarConfig.headRotationY = Math.cos(progress * Math.PI * 3) * 0.1;
    }, 30);
}

function updateStatus(text) {
    document.getElementById('status-text').textContent = text;
}

// ===== CHAT =====
function sendMessage() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();
    if (!message) return;

    addMessageToChat(message, 'user');
    input.value = '';

    showLoading(true);

    setTimeout(() => {
        showLoading(false);
        const botResponse = generateBotResponse(message);
        addMessageToChat(botResponse, 'bot');
        speakText(botResponse);
    }, 800);
}

function addMessageToChat(message, sender) {
    const container = document.getElementById('chat-messages');
    const wrapper = document.createElement('div');
    wrapper.className = `message ${sender}-message`;

    const content = document.createElement('div');
    content.className = 'message-content';
    content.textContent = message;

    wrapper.appendChild(content);
    container.appendChild(wrapper);
    container.scrollTop = container.scrollHeight;
}

function generateBotResponse(userMessage) {
    const responses = [
        "Ho ricevuto il tuo messaggio. Tutto chiaro!",
        "Interessante! Mi piace come la pensi.",
        "Sono d'accordo con te su questo punto.",
        "Ottima osservazione! Continueremo a collaborare.",
        "Understood, perfetto! Qualcos'altro?",
        "La tua input Ã¨ stata elaborata correttamente.",
        "Concordo pienamente. Andiamo avanti!",
        "Interessante prospettiva. Grazie per la condivisione.",
    ];
    return responses[Math.floor(Math.random() * responses.length)];
}

function showLoading(show) {
    const indicator = document.getElementById('loading-indicator');
    if (show) indicator.classList.add('active');
    else indicator.classList.remove('active');
}

// ENTER per inviare
document.addEventListener('DOMContentLoaded', () => {
    initThreeJS();
    updateStatus('Pronto a conversare');

    document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
    });
});
