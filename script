// ===== THREE.JS AVATAR 3D SETUP =====
let scene, camera, renderer, robot, mouthMesh;
const avatarConfig = {
    headRotationX: 0,
    headRotationY: 0,
    mouthOpen: 0,
};

function initThreeJS() {
    const container = document.getElementById('canvas-container');
    
    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1929);
    scene.fog = new THREE.Fog(0x0a1929, 100, 1000);

    // Camera setup
    camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
    );
    camera.position.set(0, 0.5, 2);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowShadowMap;
    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0x00d4ff, 0.8);
    directionalLight.position.set(5, 10, 7);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0x00ff88, 0.5);
    pointLight.position.set(-5, 5, 5);
    scene.add(pointLight);

    // Create robot avatar
    createRobotAvatar();

    // Handle window resize
    window.addEventListener('resize', onWindowResize);

    // Animation loop
    animate();
}

function createRobotAvatar() {
    robot = new THREE.Group();
    scene.add(robot);

    // Main Head (Metallic Sphere)
    const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        metalness: 0.8,
        roughness: 0.2,
    });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.castShadow = true;
    head.receiveShadow = true;
    robot.add(head);

    // Eyes (glowing)
    const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
    const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    
    const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
    leftEye.position.set(-0.18, 0.15, 0.48);
    head.add(leftEye);

    const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
    rightEye.position.set(0.18, 0.15, 0.48);
    head.add(rightEye);

    // Central lens/visor
    const visorGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.05, 32);
    const visorMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        metalness: 1,
        roughness: 0.1,
    });
    const visor = new THREE.Mesh(visorGeometry, visorMaterial);
    visor.position.z = 0.45;
    head.add(visor);

    // Mouth area (animated)
    const mouthGroupGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.1);
    const mouthMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        metalness: 0.6,
        roughness: 0.4,
    });
    mouthMesh = new THREE.Mesh(mouthGroupGeometry, mouthMaterial);
    mouthMesh.position.set(0, -0.15, 0.48);
    head.add(mouthMesh);

    // Mouth opening effect (scale in Y)
    mouthMesh.userData.defaultScaleY = 0.08;

    // Neck
    const neckGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.3, 16);
    const neckMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        metalness: 0.5,
        roughness: 0.3,
    });
    const neck = new THREE.Mesh(neckGeometry, neckMaterial);
    neck.position.y = -0.55;
    neck.castShadow = true;
    neck.receiveShadow = true;
    robot.add(neck);

    // Shoulders
    const shoulderGeometry = new THREE.BoxGeometry(1, 0.4, 0.4);
    const shoulderMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        metalness: 0.5,
        roughness: 0.3,
    });
    const shoulders = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
    shoulders.position.y = -0.85;
    shoulders.castShadow = true;
    shoulders.receiveShadow = true;
    robot.add(shoulders);

    // Arms
    const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.8, 16);
    const armMaterial = new THREE.MeshStandardMaterial({
        color: 0x666666,
        metalness: 0.6,
        roughness: 0.3,
    });

    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
    leftArm.position.set(-0.5, -0.85, 0);
    leftArm.rotation.z = Math.PI / 8;
    leftArm.castShadow = true;
    leftArm.receiveShadow = true;
    robot.add(leftArm);

    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
    rightArm.position.set(0.5, -0.85, 0);
    rightArm.rotation.z = -Math.PI / 8;
    rightArm.castShadow = true;
    rightArm.receiveShadow = true;
    robot.add(rightArm);

    // Chest panel (decorative)
    const panelGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
    const panelMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a3a52,
        metalness: 0.4,
        roughness: 0.5,
    });
    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
    panel.position.set(0, -0.9, 0.25);
    panel.castShadow = true;
    panel.receiveShadow = true;
    robot.add(panel);

    // Add glowing effect
    addGlowEffect();
}

function addGlowEffect() {
    const glowGeometry = new THREE.SphereGeometry(0.55, 32, 32);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00d4ff,
        transparent: true,
        opacity: 0.1,
        wireframe: true,
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    robot.add(glow);
}

function animate() {
    requestAnimationFrame(animate);

    // Smooth head rotation
    robot.rotation.x += (avatarConfig.headRotationX - robot.rotation.x) * 0.05;
    robot.rotation.y += (avatarConfig.headRotationY - robot.rotation.y) * 0.05;

    // Animate mouth opening
    if (mouthMesh) {
        mouthMesh.scale.y += (avatarConfig.mouthOpen - mouthMesh.scale.y) * 0.1;
    }

    // Gentle floating motion
    robot.position.y += Math.sin(Date.now() * 0.0005) * 0.001;

    renderer.render(scene, camera);
}

function onWindowResize() {
    const container = document.getElementById('canvas-container');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

// ===== SPEECH SYNTHESIS & LIP-SYNC =====
const speechSynthesis = window.speechSynthesis;
let currentUtterance = null;

function speakText(text) {
    // Cancel any ongoing speech
    speechSynthesis.cancel();

    currentUtterance = new SpeechSynthesisUtterance(text);
    currentUtterance.lang = 'it-IT'; // Italian language
    currentUtterance.rate = 1.0;
    currentUtterance.pitch = 1.0;
    currentUtterance.volume = 1.0;

    // Lip-sync animation
    const textLength = text.length;
    const duration = textLength * 50; // Estimated duration in ms

    currentUtterance.onstart = () => {
        updateStatus('ðŸŽ™ï¸ Parlando...');
        animateLipSync(duration);
    };

    currentUtterance.onend = () => {
        avatarConfig.mouthOpen = 0;
        updateStatus('Pronto a conversare');
    };

    currentUtterance.onerror = (event) => {
        console.error('Speech error:', event);
        updateStatus('âŒ Errore nella sintesi vocale');
    };

    speechSynthesis.speak(currentUtterance);
}

function animateLipSync(duration) {
    const startTime = Date.now();
    const updateInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;

        if (progress >= 1) {
            clearInterval(updateInterval);
            avatarConfig.mouthOpen = 0;
            return;
        }

        // Create natural mouth opening pattern
        const mouthPattern = Math.sin(progress * Math.PI * 4) * 0.5 + 0.3;
        avatarConfig.mouthOpen = Math.max(0, mouthPattern);

        // Head tilts slightly while speaking
        avatarConfig.headRotationX = Math.sin(progress * Math.PI * 2) * 0.05;
        avatarConfig.headRotationY = Math.cos(progress * Math.PI * 3) * 0.1;
    }, 30);
}

function updateStatus(text) {
    document.getElementById('status-text').textContent = text;
}

// ===== CHAT FUNCTIONALITY =====
function sendMessage() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();

    if (!message) return;

    // Add user message to chat
    addMessageToChat(message, 'user');
    input.value = '';

    // Show loading
    showLoading(true);

    // Simulate bot response delay
    setTimeout(() => {
        showLoading(false);

        // Generate bot response
        const botResponse = generateBotResponse(message);
        addMessageToChat(botResponse, 'bot');

        // Make avatar speak
        speakText(botResponse);
    }, 800);
}

function addMessageToChat(message, sender) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;

    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    contentDiv.textContent = message;

    messageDiv.appendChild(contentDiv);
    messagesContainer.appendChild(messageDiv);

    // Auto-scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function generateBotResponse(userMessage) {
    const responses = [
        "Ho ricevuto il tuo messaggio. Tutto chiaro!",
        "Interessante! Mi piace come la pensi.",
        "Sono d'accordo con te su questo punto.",
        "Ottima osservazione! Continueremo a collaborare.",
        "Understood, perfetto! Qualcos'altro?",
        "La tua input Ã¨ stata elaborata correttamente.",
        "Concordo pienamente. Andiamo avanti!",
        "Interessante prospettiva. Grazie per la condivisione.",
    ];
    return responses[Math.floor(Math.random() * responses.length)];
}

function showLoading(show) {
    const indicator = document.getElementById('loading-indicator');
    if (show) {
        indicator.classList.add('active');
    } else {
        indicator.classList.remove('active');
    }
}

// ===== EVENT LISTENERS =====
document.getElementById('chat-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        sendMessage();
    }
});

// ===== INITIALIZE =====
window.addEventListener('DOMContentLoaded', () => {
    initThreeJS();
    updateStatus('Pronto a conversare');
});